"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from slackspec.models import operations
from typing import Any, Optional

class Conversations:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    
    def conversations_archive(self, request: operations.ConversationsArchiveRequest, security: operations.ConversationsArchiveSecurity) -> operations.ConversationsArchiveResponse:
        r"""Archives a conversation.
        https://api.slack.com/methods/conversations.archive - API method documentation
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations.archive'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ConversationsArchiveResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_archive_success_schema = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_archive_error_schema = out

        return res

    
    def conversations_close(self, request: operations.ConversationsCloseRequest, security: operations.ConversationsCloseSecurity) -> operations.ConversationsCloseResponse:
        r"""Closes a direct message or multi-person direct message.
        https://api.slack.com/methods/conversations.close - API method documentation
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations.close'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ConversationsCloseResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_close_success_schema = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_close_error_schema = out

        return res

    
    def conversations_create(self, request: operations.ConversationsCreateRequest, security: operations.ConversationsCreateSecurity) -> operations.ConversationsCreateResponse:
        r"""Initiates a public or private channel-based conversation
        https://api.slack.com/methods/conversations.create - API method documentation
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations.create'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ConversationsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_create_success_schema = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_create_error_schema = out

        return res

    
    def conversations_history(self, request: operations.ConversationsHistoryRequest, security: operations.ConversationsHistorySecurity) -> operations.ConversationsHistoryResponse:
        r"""Fetches a conversation's history of messages and events.
        https://api.slack.com/methods/conversations.history - API method documentation
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations.history'
        
        query_params = utils.get_query_params(operations.ConversationsHistoryRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ConversationsHistoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_history_success_schema = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_history_error_schema = out

        return res

    
    def conversations_info(self, request: operations.ConversationsInfoRequest, security: operations.ConversationsInfoSecurity) -> operations.ConversationsInfoResponse:
        r"""Retrieve information about a conversation.
        https://api.slack.com/methods/conversations.info - API method documentation
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations.info'
        
        query_params = utils.get_query_params(operations.ConversationsInfoRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ConversationsInfoResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_info_success_schema = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_info_error_schema = out

        return res

    
    def conversations_invite(self, request: operations.ConversationsInviteRequest, security: operations.ConversationsInviteSecurity) -> operations.ConversationsInviteResponse:
        r"""Invites users to a channel.
        https://api.slack.com/methods/conversations.invite - API method documentation
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations.invite'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ConversationsInviteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if True:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_invite_error_schema = out

        return res

    
    def conversations_join(self, request: operations.ConversationsJoinRequest, security: operations.ConversationsJoinSecurity) -> operations.ConversationsJoinResponse:
        r"""Joins an existing conversation.
        https://api.slack.com/methods/conversations.join - API method documentation
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations.join'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ConversationsJoinResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_join_success_schema = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_join_error_schema = out

        return res

    
    def conversations_kick(self, request: operations.ConversationsKickRequest, security: operations.ConversationsKickSecurity) -> operations.ConversationsKickResponse:
        r"""Removes a user from a conversation.
        https://api.slack.com/methods/conversations.kick - API method documentation
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations.kick'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ConversationsKickResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_kick_success_schema = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_kick_error_schema = out

        return res

    
    def conversations_leave(self, request: operations.ConversationsLeaveRequest, security: operations.ConversationsLeaveSecurity) -> operations.ConversationsLeaveResponse:
        r"""Leaves a conversation.
        https://api.slack.com/methods/conversations.leave - API method documentation
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations.leave'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ConversationsLeaveResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_leave_success_schema = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_leave_error_schema = out

        return res

    
    def conversations_list(self, request: operations.ConversationsListRequest, security: operations.ConversationsListSecurity) -> operations.ConversationsListResponse:
        r"""Lists all channels in a Slack team.
        https://api.slack.com/methods/conversations.list - API method documentation
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations.list'
        
        query_params = utils.get_query_params(operations.ConversationsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ConversationsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_list_success_schema = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_list_error_schema = out

        return res

    
    def conversations_mark(self, request: operations.ConversationsMarkRequest, security: operations.ConversationsMarkSecurity) -> operations.ConversationsMarkResponse:
        r"""Sets the read cursor in a channel.
        https://api.slack.com/methods/conversations.mark - API method documentation
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations.mark'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ConversationsMarkResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_mark_success_schema = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_mark_error_schema = out

        return res

    
    def conversations_members(self, request: operations.ConversationsMembersRequest, security: operations.ConversationsMembersSecurity) -> operations.ConversationsMembersResponse:
        r"""Retrieve members of a conversation.
        https://api.slack.com/methods/conversations.members - API method documentation
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations.members'
        
        query_params = utils.get_query_params(operations.ConversationsMembersRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ConversationsMembersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_members_success_schema = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_members_error_schema = out

        return res

    
    def conversations_open(self, request: operations.ConversationsOpenRequest, security: operations.ConversationsOpenSecurity) -> operations.ConversationsOpenResponse:
        r"""Opens or resumes a direct message or multi-person direct message.
        https://api.slack.com/methods/conversations.open - API method documentation
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations.open'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ConversationsOpenResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_open_success_schema = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_open_error_schema = out

        return res

    
    def conversations_rename(self, request: operations.ConversationsRenameRequest, security: operations.ConversationsRenameSecurity) -> operations.ConversationsRenameResponse:
        r"""Renames a conversation.
        https://api.slack.com/methods/conversations.rename - API method documentation
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations.rename'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ConversationsRenameResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_rename_success_schema = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_rename_error_schema = out

        return res

    
    def conversations_replies(self, request: operations.ConversationsRepliesRequest, security: operations.ConversationsRepliesSecurity) -> operations.ConversationsRepliesResponse:
        r"""Retrieve a thread of messages posted to a conversation
        https://api.slack.com/methods/conversations.replies - API method documentation
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations.replies'
        
        query_params = utils.get_query_params(operations.ConversationsRepliesRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ConversationsRepliesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_replies_success_schema = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_replies_error_schema = out

        return res

    
    def conversations_set_purpose(self, request: operations.ConversationsSetPurposeRequest, security: operations.ConversationsSetPurposeSecurity) -> operations.ConversationsSetPurposeResponse:
        r"""Sets the purpose for a conversation.
        https://api.slack.com/methods/conversations.setPurpose - API method documentation
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations.setPurpose'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ConversationsSetPurposeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_set_purpose_success_schema = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_set_purpose_error_schema = out

        return res

    
    def conversations_set_topic(self, request: operations.ConversationsSetTopicRequest, security: operations.ConversationsSetTopicSecurity) -> operations.ConversationsSetTopicResponse:
        r"""Sets the topic for a conversation.
        https://api.slack.com/methods/conversations.setTopic - API method documentation
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations.setTopic'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ConversationsSetTopicResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_set_topic_success_schema = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_set_topic_error_schema = out

        return res

    
    def conversations_unarchive(self, request: operations.ConversationsUnarchiveRequest, security: operations.ConversationsUnarchiveSecurity) -> operations.ConversationsUnarchiveResponse:
        r"""Reverses conversation archival.
        https://api.slack.com/methods/conversations.unarchive - API method documentation
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations.unarchive'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ConversationsUnarchiveResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_unarchive_success_schema = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, dict[str, Any]]])
                res.conversations_unarchive_error_schema = out

        return res

    